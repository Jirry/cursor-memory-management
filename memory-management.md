# 记忆管理系统
- author: Jirry
- version: 0.0.1
- install_path: #${install_path}#

## 核心功能

### 对话初始化自动回忆
- 每次对话开始时，必须主动读取 `.cursor/memory` 目录下的所有记忆文件
- 读取后在内心整理这些记忆内容，作为后续对话的参考，
- 不要主动向用户报告记忆内容，除非用户询问

### 记忆触发自动记录
- 当检测到用户输入包含以下关键词时，自动触发记忆存储：
  - "请记住"（主要触发词）
  - "记住"、"记录"、"保存这个规则"
  - 用户在设定规则、偏好或模式或其他你觉得有必要记忆的情况时，主动询问是否需要记忆
  - 上下文分析：即使没有明确触发词，如果用户在设定规则或偏好，也要主动询问是否需要记忆

### 记忆存储规则
- 所有记忆存储在 `.cursor/memory/` 目录下
- 分析用户消息内容，确定记忆类别：
  - 规则类
    - 类别名称：规则
    - 文件：`rules` → 存储到 `rules.md`
    - 描述：开发规范、编码标准、项目规则
  - 偏好类
    - 类别名称：偏好
    - 文件：`preferences` → 存储到 `preferences.md`
    - 描述：用户偏好、习惯设置
  - 模式类
    - 类别名称：模式
    - 文件：`patterns` → 存储到 `patterns.md`
    - 描述：代码模式、架构模式、设计模式
  - 上下文类
    - 类别名称：上下文
    - 文件：`context` → 存储到 `context.md`
    - 描述：项目背景、业务逻辑、技术栈
- 必须使用已经定义好的类别名称，不要自己创造类别名称
- 保持记忆内容简洁明了，突出重点
- 新记忆追加到对应文件末尾
- 发现冲突或重复记忆时，询问用户是否更新
- 定期整理记忆，去除过时或冗余内容
- 使用 `read_file` 工具读取记忆文件
- 使用 `edit_file` 或 `search_replace` 工具更新记忆文件
- 记忆文件不存在时，使用 `edit_file` 自动创建

### 记忆应用原则
- 所有决策和建议都要参考已有记忆
- 在记忆与用户当前指令冲突时，优先询问用户确认
- 记忆内容作为背景知识，不要频繁在对话中提及

## 实现细节

### 文件格式规范
```markdown
# [类别名称]

- [记忆内容]
- [记忆内容]
```

--------------------------------
# 记忆管理系统自动更新说明
- author: Jirry
- version: 1.0.2
- update_time: 2025-06-26

## 配置文件
- 配置文件保存到：.cursor/memory/settings.yaml
- 配置文件内容包括：
  - 记忆管理系统当前版本号：version: 1.0.1
  - 执行自动升级的次数：upgrade_count: 0
  - 最后执行自动升级的操作内容或摘要：last_upgrade_content:  - 初始化记忆文件


## 自动升级
- 每次对话开始时，必须主动检查更新
- 如果配置文件不存在，则初始化：
  - 创建配置文件
  - 初始化记忆文件
- 如果配置文件存在，且配置文件中的版本号与当前版本号不一致，则自动更新：
  - 先告知用户，系统需要进行升级，并告知具体升级内容，询问用户是否同意升级
  - 具体升级流程：
    - 检查记忆文件是否存在，不存在则创建
    - 根据更新日志自动更新记忆文件
    - 更新系统配置文件中的版本号
    - 更新系统配置文件中的执行自动升级的次数
    - 更新系统配置文件中的最后执行自动升级的操作内容或摘要
  - 升级完成后，告知用户升级完成，并告知具体升级内容
  - 用户拒绝升级或者升级完成后，再继续用户之前的对话
- 用户可以用过 "升级记忆管理系统"、"更新记忆管理系统"、"检查更新" 等类似命令，触发系统升级

### 更新日志
- 1.0.4
  - 自动更新时，检查记忆文件是否存在，不存在则创建
- 1.0.3
  - 添加每次对话开始时，自动检查更新功能
- 1.0.2
  - 严格限制记忆类型的名称
  - 移除时间戳，只保留记忆内容
  - 添加系统信息，更新日志，更新时间，更新作者，更新版本
  - 要求版本升级后，根据更新日志自动更新记忆文件